{"version":3,"sources":["/projects/nodejs/botbuilder/fdevstart/src/../src/match/sentence.ts"],"names":[],"mappings":"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","file":"match/sentence.js","sourcesContent":["/**\n * @file sentence\n * @module jfseb.fdevstart.sentence\n * @copyright (c) Gerd Forstmann\n *\n * Match a tool record on a sentence,\n *\n * This will unify matching required and optional category words\n * with the requirements of the tool.\n *\n */\n\n// <reference path=\"../../lib/node-4.d.ts\" />\n\nimport * as debug from 'debug';\n\n// import * as utils from '../utils/utils';\n\nimport * as IMatch from './ifmatch';\n\nconst debuglog = debug('sentence')\n\nexport function findWordByCategory(oSentence, sCategory : string) : { word : IMatch.IWord, index : number} {\n  \tvar res = {} as { word : IMatch.IWord, index : number};\n    oSentence.every(function(oWord, iIndex) {\n      if(oWord.category === sCategory) {\n        res = { word: oWord,\n                index : iIndex };\n        return false;\n      }\n      return true;\n    })\n    return res;\n}\n\nexport function getDistinctCategoriesInSentence(oSentence : IMatch.ISentence) : string[] {\n  var res = [];\n  var resm = {};\n  oSentence.forEach(function(oWord) {\n    if(oWord.category === \"category\") {\n      if(!resm[oWord.matchedString]) {\n        res.push(oWord.matchedString);\n        resm[oWord.matchedString] = 1;\n      }\n    }\n  });\n  return res;\n}\n\nexport function rankingGeometricMean(oSentence : IMatch.ISentence) : number {\n  const length = oSentence.length;\n  if(length === 0) {\n    return 1.0;\n  }\n  var prod =  oSentence.reduce(function(prev, oWord) {\n    return prev * (oWord._ranking || 1.0);\n  },1.0);\n  // TODO: find somethign faster ;-)\n  return Math.pow(prod, 1/length);\n}\n\nexport function rankingProduct(oSentence: IMatch.ISentence) : number {\n  return rankingGeometricMean(oSentence);\n}\n\nexport function cmpRankingProduct(a : IMatch.ISentence, b : IMatch.ISentence) {\n  return - (rankingProduct(a) - rankingProduct(b));\n}\n\nexport function cutoffSentenceAtRatio(sentences : IMatch.ISentence[]) {\n  if(sentences.length === 0){\n    return sentences;\n  }\n  var bestRank = rankingProduct(sentences[0]);\n  for(var i = 1; (i < Math.min(sentences.length, 300)) && ((rankingProduct(sentences[i])/ bestRank) > 0.8); ++ i) {\n    // empty\n  }\n  debuglog(\"reduce sentences by \" + i + \"/\" + sentences.length);\n  return sentences.slice(0,i);\n}\n\nexport function dumpNice(sentence : IMatch.ISentence, fn?: any) : string {\n  var result = [];\n    sentence.forEach(function(oWord, index) {\n      var sWord = `[${index}] : ${(oWord._ranking || 0).toFixed(3)} ${oWord.category} \"${oWord.string}\" => \"${oWord.matchedString}\"`\n      result.push(sWord + \"\\n\");\n    })\n    result.push(\".\\n\");\n    return result.join(\"\");\n}\n\n\nexport function dumpNiceArr(sentences : IMatch.ISentence[], fn? : any) : string {\n  if(!sentences) {\n    return \"\";\n  }\n  var res = sentences.reduce(function(prev, oSentence) {\n    return prev + dumpNice(oSentence);\n  }, \"\")\n  return res;\n}"],"sourceRoot":"ABC"}