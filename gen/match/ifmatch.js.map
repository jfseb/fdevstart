{"version":3,"sources":["/projects/nodejs/botbuilder/fdevstart/src/../src/match/ifmatch.ts"],"names":[],"mappings":";;AAEA,qDAA0C;AAE1C,IAAkB,gBAIjB;AAJD,WAAkB,gBAAgB;IAChC,6DAAW,CAAA;IACX,uDAAI,CAAA;IACJ,yDAAK,CAAA;AACP,CAAC,EAJiB,gBAAgB,GAAhB,wBAAgB,KAAhB,wBAAgB,QAIjC;AAGY,QAAA,YAAY,GAAG,UAAU,CAAC;AAC1B,QAAA,UAAU,GAAG,QAAQ,CAAC;AACtB,QAAA,QAAQ,GAAG,MAAM,CAAC;AAGlB,QAAA,iBAAiB,GAAG,eAAe,CAAC;AACpC,QAAA,eAAe,GAAG,aAAa,CAAC;AAK5C,CAAC;AAQD,CAAC;AAaW,QAAA,cAAc,GAAG,CAAC,eAAe,EAAE,aAAa,EAAE,YAAY,EAAE,WAAW,EAAE,QAAQ,EAAE,OAAO,CAAC,CAAC;AAoD5G,CAAC;AAoBG,CAAC;AAiEL,CAAC;AAIe,CAAC;AA2EjB,CAAC;AAaD,CAAC;AA4BF,IAAkB,cAGjB;AAHD,WAAkB,cAAc;IAC9B,2DAAQ,CAAA;IACR,mEAAY,CAAA;AACd,CAAC,EAHiB,cAAc,GAAd,sBAAc,KAAd,sBAAc,QAG/B;AAoCA,CAAC;AAEW,QAAA,YAAY,GAAG,yBAAO,CAAC,YAAY,CAAC;AAGjD,+DAA+D;AAC/D;;;;;;;;;;;;;;;;;;;;;;;;;EAyBE","file":"match/ifmatch.js","sourcesContent":["\r\n\r\nimport { IFModel } from 'fdevsta_monmove';\r\n\r\nexport const enum EnumResponseCode {\r\n  NOMATCH = 0,\r\n  EXEC,\r\n  QUERY\r\n}\r\n\r\n\r\nexport const CAT_CATEGORY = \"category\";\r\nexport const CAT_FILLER = \"filler\";\r\nexport const CAT_TOOL = \"tool\";\r\n\r\n\r\nexport const ERR_NO_KNOWN_WORD = \"NO_KNOWN_WORD\";\r\nexport const ERR_EMPTY_INPUT = \"EMPTY_INPUT\";\r\n\r\nexport interface IERError {\r\n  err_code : string,\r\n  text : string\r\n};\r\n\r\nexport interface IERErrorNO_KNOWN_WORD extends IERError{\r\n  context : {\r\n    token : string,\r\n    index: number,\r\n    tokens : string[]\r\n  }\r\n};\r\n\r\n\r\n\r\nexport interface IPromptDescription {\r\n  description: string,\r\n  type: string,\r\n  pattern: RegExp,\r\n  message: string,\r\n  default: string,\r\n  required: boolean\r\n}\r\n\r\nexport const aOperatorNames = [\"starting with\", \"ending with\", \"containing\", \"excluding\", \"having\", \"being\"];\r\nexport type OperatorName = \"starting with\" | \"ending with\" | \"containing\" | \"being\" | \"excluding\" | \"having\";\r\n\r\nexport interface IOperator {\r\n  operator : OperatorName,\r\n  code : string,\r\n  arity : number,\r\n  argcategory : [ string[] ]\r\n}\r\n\r\nexport type IRecord = { [key : string] : string\r\n};\r\n\r\n\r\nexport interface IWhatIsAnswer {\r\n  sentence: ISentence,\r\n  record : IRecord,\r\n  category : string,\r\n  result: string,\r\n  _ranking : number\r\n}\r\n\r\nexport type IRule = IFModel.IRule;\r\n\r\nexport type mRule = IFModel.mRule;\r\n\r\n\r\nexport interface IProcessedWhatIsAnswers extends IProcessed {\r\n  sentences? : ISentence[],\r\n  answers : IWhatIsAnswer[]\r\n}\r\n\r\n\r\n\r\nexport interface IProcessedWhatIsTupelAnswers extends IProcessed {\r\n  sentences? : ISentence[],\r\n  tupelanswers : Array<IWhatIsTupelAnswer>\r\n}\r\n\r\n\r\nexport interface IWhatIsTupelAnswer {\r\n  sentence: ISentence,\r\n  record : IRecord,\r\n  categories : string[],\r\n  result: string[],\r\n  _ranking : number\r\n}\r\n\r\n\r\nexport interface IMatchedSetRecord {\r\n  setId : string,\r\n  record : IRecord\r\n};\r\nexport type IMatchedSetRecords = IMatchedSetRecord[];\r\n/**\r\n * Map category -> value\r\n */\r\nexport type IMatchSet = { [key : string] : string};\r\n\r\nexport type EnumRuleType = IFModel.EnumRuleType;\r\n\r\n//export const enum EnumRuleType = IFModel.EnumRuleType;\r\n/*\r\nexport const  enum EnumRuleType {\r\n  WORD,\r\n  REGEXP\r\n}\r\n*/\r\n\r\nexport interface IToolSet {\r\n      set: string[],\r\n      response: string\r\n    };\r\n\r\nexport type IToolSets = {\r\n    [key: string]: IToolSet\r\n    };\r\n/**\r\n * @interface ITool\r\n *\r\n * var oTool = { 'name' : 'FLPD',\r\n *   'requires' : { 'systemId' : {}, 'client' :{}},\r\n *   'optional' : { 'catalog' : {}, 'group' :{}}\r\n * };\r\n*/\r\nexport interface ITool {\r\n  name: string,\r\n  requires: { [key: string]: Object },\r\n  optional?: { [key: string]: Object },\r\n  sets?: IToolSets\r\n}\r\n\r\nexport interface IToolMatchResult {\r\n  required: { [key: string]: IWord },\r\n  missing: { [key: string]: number },\r\n  optional?: { [key: string]: IWord },\r\n  spurious: { [key: string]: number },\r\n  toolmentioned: IWord[]\r\n}\r\n\r\nexport interface IPrompt {\r\n  text: string,\r\n  category: string\r\n}\r\n\r\nexport interface IToolMatch {\r\n  toolmatchresult: IToolMatchResult,\r\n  sentence: ISentence,\r\n  tool: ITool,\r\n  rank: number\r\n}\r\n\r\nexport interface IWord {\r\n  string: string,\r\n  matchedString: string,\r\n  category: string,\r\n  _ranking?: number,\r\n  levenmatch?: number,\r\n  reinforce?: number,\r\n  bitindex? : number,\r\n  rule? : IFModel.mRule\r\n}\r\n\r\nexport type ISentence = Array<IWord>;\r\n\r\n\r\nexport interface IntentRule {\r\n  type: EnumRuleType,\r\n  regexp: RegExp,\r\n  argsMap: { [key: string]: number }  // a map of regexp match group -> context key\r\n  // e.g. /([a-z0-9]{3,3})CLNT([\\d{3,3}])/\r\n  //      { 1 : \"systemId\", 2 : \"client\" }\r\n  follows?: context\r\n}\r\n\r\nexport interface IRange {\r\n  low: number, high: number,\r\n};\r\n\r\nexport interface IWordRange extends IRange\r\n{\r\n  rule? : mRule };\r\n/**\r\n * A rule matching a single string\r\n */\r\n\r\n//import { IErRule } from 'abot_erbase'\r\n\r\n/*}\r\n\r\nexport interface mRule {\r\n  type: EnumRuleType,\r\n  word?: string,\r\n  lowercaseword? : string,\r\n  regexp?: RegExp,\r\n  matchedString?: string,\r\n  matchIndex?: number,\r\n  category: string,\r\n  bitindex : number,\r\n  range? :  IWordRange,\r\n  /* *\r\n   * only use an exact match\r\n   * /\r\n  exactOnly? : boolean,\r\n  _ranking?: number\r\n}\r\n*/\r\n\r\nexport interface IWordRules {\r\n  rules : Array<IFModel.mRule>,\r\n  bitindex: number\r\n}\r\nexport type SplitRules = IFModel.SplitRules;\r\n/*\r\nexport interface SplitRules {\r\n  allRules: Array<mRule>,\r\n  nonWordRules : Array<mRule>,\r\n  wordMap: { [key : string] : IWordRules },\r\n  wordCache :  { [key: string]: Array<ICategorizedString> }\r\n};\r\n*/\r\n\r\nexport interface ICategorizedString {\r\n  string: string,\r\n  matchedString: string,\r\n  category: string,\r\n  breakdown?: Array<any>\r\n  score?: number,\r\n  _ranking?: number,\r\n  levenmatch?: number  // a distance ranking\r\n}\r\n\r\nexport interface ICategorizedStringRanged extends ICategorizedString{\r\n  string: string,\r\n  matchedString: string,\r\n  category: string,\r\n  breakdown?: Array<any>\r\n  /**\r\n   * Length of the entry (for skipping following words)\r\n   */\r\n  score?: number,\r\n  span? : number,\r\n  rule : mRule,\r\n  _ranking?: number,\r\n  levenmatch?: number  // a distance ranking\r\n}\r\n\r\nexport interface IProcessed {\r\n  tokens : string[],\r\n  errors? : IERError[]\r\n}\r\n\r\nexport interface IProcessedSentences extends IProcessed {\r\n  tokens : string[],\r\n  errors? : any,\r\n  sentences : ISentence[]\r\n};\r\n\r\nexport type ICategoryFilter = { [key: string]: boolean };\r\n\r\n\r\nexport type IDomainCategoryFilter = {\r\n  domains : string[],\r\n  categorySet : { [key: string]: boolean }\r\n}\r\n\r\n\r\nexport interface IProcessedExtractedCategories extends IProcessed {\r\n  categories : string[],\r\n};\r\n\r\n\r\n\r\nexport type context = { [key: string]: string };\r\n\r\n/**\r\n * Defines the interface for an analysis\r\n * reponse\r\n */\r\nexport interface IResponse {\r\n  rating: number,\r\n  type: EnumResponseCode,\r\n  query: string,\r\n  context: { [key: string]: string },\r\n  text: string,\r\n  action: IAction,\r\n  prompts: {\r\n    [key: string]: {\r\n      text: string,\r\n      /**\r\n       * Follows the features of NPM prompts\r\n       */\r\n      description: IPromptDescription\r\n    };\r\n  }\r\n}\r\n\r\nexport const enum EnumActionType {\r\n  STARTURL,\r\n  STARTCMDLINE\r\n}\r\n\r\nexport interface IAction {\r\n  data: any,\r\n  type: EnumActionType,\r\n  pattern: string,\r\n  concrete: string\r\n}\r\n\r\n\r\nexport interface ICategoryDesc {\r\n  name: string,\r\n  importance? : number,\r\n  description? : string,\r\n  iskey? : boolean\r\n  exactMatch: boolean,\r\n  synonyms? : string[];\r\n}\r\n\r\n\r\n\r\nexport interface IModel {\r\n    domain: string,\r\n    bitindex : number,\r\n    description? : string,\r\n    tool: ITool,\r\n    toolhidden?: boolean,\r\n    synonyms?: { [key: string]: string[] },\r\n    categoryDescribed :  { name : string,\r\n        description? : string,\r\n        key? : string }[],\r\n    category: string[],\r\n    columns? : string[],\r\n    wordindex: string[],\r\n    exactmatch? : string[],\r\n    hidden: string[]\r\n};\r\n\r\nexport const EnumRuleType = IFModel.EnumRuleType;\r\nexport type IModels = IFModel.IModels;\r\n\r\n//export { IFModel.IModels as IModels } from 'fdevsta_monmove';\r\n/*\r\n\r\nexport interface IModels {\r\n    full : {\r\n      domain : { [key : string] : {\r\n          description: string,\r\n          bitindex : number,\r\n          categories : { [key : string] : ICategoryDesc }\r\n        }\r\n      }\r\n    },\r\n    rawModels : { [key : string] : IModel};\r\n    domains: string[],\r\n    tools: ITool[],\r\n    category: string[],\r\n    operators : { [key: string] : IOperator },\r\n    mRules: mRule[],\r\n    rules : SplitRules,\r\n    records: any[]\r\n    seenRules?: { [key: string]: mRule[] },\r\n    meta : {\r\n        // entity -> relation -> target\r\n        t3 : { [key: string] : { [key : string] : any }}\r\n    }\r\n}\r\n*/"],"sourceRoot":"ABC"}