{"version":3,"sources":["/projects/nodejs/botbuilder/fdevstart/src/../src/match/whatis.ts"],"names":[],"mappings":"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","file":"match/whatis.js","sourcesContent":["/**\n *\n * @module jfseb.fdevstart.analyze\n * @file analyze.ts\n * @copyright (c) 2016 Gerd Forstmann\n */\n\n\nimport { InputFilter as InputFilter} from 'abot_erbase';\n\nimport * as debug from 'debug';\n\nvar debuglog = debug('whatis');\nvar debuglogV = debug('whatVis');\nvar perflog = debug('perf');\n\n\nimport { ErError as ErError} from 'abot_erbase';\n\nimport { ErBase as ErBase} from 'abot_erbase';\n\n\nexport function mockDebug(o) {\n  debuglog = o;\n  debuglogV = o;\n  perflog = o;\n}\n\n\nimport * as _ from 'lodash';\n\nimport * as IMatch from './ifmatch';\n\nimport * as Match from './match';\n\nimport * as Toolmatcher from './toolmatcher';\n\nimport { Sentence as Sentence} from 'abot_erbase';\n\nimport { Word as Word}  from 'abot_erbase';\n\nimport * as Algol from './algol';\n\nimport {Model as Model}  from 'fdevsta_monmove';\n\n\n\n/*\nexport function cmpByResultThenRanking(a: IMatch.IWhatIsAnswer, b: IMatch.IWhatIsAnswer) {\n  var cmp = a.result.localeCompare(b.result);\n  if (cmp) {\n    return cmp;\n  }\n  return -(a._ranking - b._ranking);\n}\n*/\n\nfunction localeCompareArrs(aaresult: string[], bbresult: string[]): number {\n  var cmp = 0;\n  var blen = bbresult.length;\n  aaresult.every(function (a, index) {\n    if (blen <= index) {\n      cmp = -1;\n      return false;\n    }\n    cmp = a.localeCompare(bbresult[index]);\n    if (cmp) {\n      return false;\n    }\n    return true;\n  });\n  if (cmp) {\n    return cmp;\n  }\n  if (blen > aaresult.length) {\n    cmp = +1;\n  }\n  return 0;\n}\n\nexport function safeEqual(a : number, b : number) : boolean {\n  var delta = a - b ;\n  if(Math.abs(delta) < Algol.RANKING_EPSILON) {\n    return true;\n  }\n  return false;\n}\n\nexport function safeDelta(a : number, b : number) : number {\n  var delta = a - b ;\n  if(Math.abs(delta) < Algol.RANKING_EPSILON) {\n    return 0;\n  }\n  return delta;\n}\n\nexport function cmpByResultThenRankingTupel(aa: IMatch.IWhatIsTupelAnswer, bb: IMatch.IWhatIsTupelAnswer) {\n  var cmp = localeCompareArrs(aa.result, bb.result);\n  if (cmp) {\n    return cmp;\n  }\n  return -safeDelta(aa._ranking,bb._ranking);\n}\n\n\nexport function cmpRecords(a: IMatch.IRecord, b: IMatch.IRecord) : number {\n// are records different?\n  var keys = Object.keys(a).concat(Object.keys(b)).sort();\n  var res = keys.reduce(function (prev, sKey) {\n    if (prev) {\n      return prev;\n    }\n    if (b[sKey] !== a[sKey]) {\n      if (!b[sKey]) {\n        return -1;\n      }\n      if (!a[sKey]) {\n        return +1;\n      }\n      return a[sKey].localeCompare(b[sKey]);\n    }\n    return 0;\n  }, 0);\n  return res;\n}\n\nexport function cmpByRanking(a: IMatch.IWhatIsAnswer, b: IMatch.IWhatIsAnswer) : number {\n  var cmp = - safeDelta(a._ranking, b._ranking) as number;\n  if (cmp) {\n    return cmp;\n  }\n  cmp = a.result.localeCompare(b.result);\n  if (cmp) {\n    return cmp;\n  }\n\n  return cmpRecords(a.record,b.record);\n}\n\n\nexport function cmpByRankingTupel(a: IMatch.IWhatIsTupelAnswer, b: IMatch.IWhatIsTupelAnswer) : number {\n  var cmp = - safeDelta(a._ranking, b._ranking);\n  if (cmp) {\n    return cmp;\n  }\n  cmp = localeCompareArrs(a.result, b.result);\n  if (cmp) {\n    return cmp;\n  }\n  return  cmpRecords(a.record,b.record);\n}\n\n\nexport function dumpNice(answer: IMatch.IWhatIsAnswer) {\n  var result = {\n    s: \"\",\n    push: function (s) { this.s = this.s + s; }\n  };\n  var s =\n    `**Result for category: ${answer.category} is ${answer.result}\n rank: ${answer._ranking}\n`;\n  result.push(s);\n  Object.keys(answer.record).forEach(function (sRequires, index) {\n    if (sRequires.charAt(0) !== '_') {\n      result.push(`record: ${sRequires} -> ${answer.record[sRequires]}`);\n    }\n    result.push('\\n');\n  });\n  var oSentence = answer.sentence;\n  oSentence.forEach(function (oWord, index) {\n    var sWord = `[${index}] : ${oWord.category} \"${oWord.string}\" => \"${oWord.matchedString}\"`\n    result.push(sWord + \"\\n\");\n  })\n  result.push(\".\\n\");\n  return result.s;\n}\nexport function dumpNiceTupel(answer: IMatch.IWhatIsTupelAnswer) {\n  var result = {\n    s: \"\",\n    push: function (s) { this.s = this.s + s; }\n  };\n  var s =\n    `**Result for categories: ${answer.categories.join(\";\")} is ${answer.result}\n rank: ${answer._ranking}\n`;\n  result.push(s);\n  Object.keys(answer.record).forEach(function (sRequires, index) {\n    if (sRequires.charAt(0) !== '_') {\n      result.push(`record: ${sRequires} -> ${answer.record[sRequires]}`);\n    }\n    result.push('\\n');\n  });\n  var oSentence = answer.sentence;\n  oSentence.forEach(function (oWord, index) {\n    var sWord = `[${index}] : ${oWord.category} \"${oWord.string}\" => \"${oWord.matchedString}\"`\n    result.push(sWord + \"\\n\");\n  })\n  result.push(\".\\n\");\n  return result.s;\n}\n\n\nexport function dumpWeightsTop(toolmatches: Array<IMatch.IWhatIsAnswer>, options: any) {\n  var s = '';\n  toolmatches.forEach(function (oMatch, index) {\n    if (index < options.top) {\n      s = s + \"WhatIsAnswer[\" + index + \"]...\\n\";\n      s = s + dumpNice(oMatch);\n    }\n  });\n  return s;\n}\n\nexport function filterDistinctResultAndSortTupel(res: IMatch.IProcessedWhatIsTupelAnswers): IMatch.IProcessedWhatIsTupelAnswers {\n  var result = res.tupelanswers.filter(function (iRes, index) {\n    if (debuglog.enabled) {\n      debuglog(' retain tupel ' + index + ' ' + JSON.stringify(iRes));\n    }\n    if (_.isEqual(iRes.result, res.tupelanswers[index - 1] && res.tupelanswers[index - 1].result)) {\n      debuglog('skip');\n      return false\n    }\n    return true;\n  });\n  result.sort(cmpByRankingTupel);\n  return Object.assign(res, { tupelanswers: result });\n}\n\n\nexport function filterOnlyTopRanked(results: Array<IMatch.IWhatIsAnswer>): Array<IMatch.IWhatIsAnswer> {\n  var res = results.filter(function (result) {\n    if (safeEqual(result._ranking, results[0]._ranking)) {\n      return true;\n    }\n    if (result._ranking >= results[0]._ranking) {\n      throw new Error(\"List to filter must be ordered\");\n    }\n    return false;\n  });\n  return res;\n}\n\nexport function filterOnlyTopRankedTupel(results: Array<IMatch.IWhatIsTupelAnswer>): Array<IMatch.IWhatIsTupelAnswer> {\n  var res = results.filter(function (result) {\n    if ( safeEqual(result._ranking, results[0]._ranking)) {\n      return true;\n    }\n    if (result._ranking >= results[0]._ranking) {\n      throw new Error(\"List to filter must be ordered\");\n    }\n    return false;\n  });\n  return res;\n}\n\n\n/**\n * A ranking which is purely based on the numbers of matched entities,\n * disregarding exactness of match\n */\n/*\nexport function calcRankingSimple(matched: number,\n  mismatched: number, nouse: number,\n  relevantCount: number): number {\n  // 2 : 0\n  // 1 : 0\n  var factor = matched * Math.pow(1.5, matched) * Math.pow(1.5, matched);\n  var factor2 = Math.pow(0.4, mismatched);\n  var factor3 = Math.pow(0.4, nouse);\n  return Math.pow(factor2 * factor * factor3, 1 / (mismatched + matched + nouse));\n}\n*/\n\nexport function calcRankingHavingCategory(matched: { [key: string]: IMatch.IWord },\n  hasCategory: { [key: string]: number },\n  mismatched: { [key: string]: IMatch.IWord }, relevantCount: number, hasDomain : number): number {\n\n\n  var lenMatched = Object.keys(matched).length;\n  var factor = Match.calcRankingProduct(matched);\n  factor *= Math.pow(1.5, lenMatched);\n  if(hasDomain) {\n    factor *= 1.5;\n  }\n  var lenHasCategory = Object.keys(hasCategory).length;\n  var factorH = Math.pow(1.1, lenHasCategory);\n\n  var lenMisMatched = Object.keys(mismatched).length;\n  var factor2 = Match.calcRankingProduct(mismatched);\n  factor2 *= Math.pow(0.4, lenMisMatched);\n  var divisor =  (lenMisMatched + lenHasCategory + lenMatched);\n  divisor = divisor ? divisor : 1;\n  return Math.pow(factor2 * factorH * factor, 1 / (divisor));\n}\n\n/**\n * list all top level rankings\n */\n/*\nexport function matchRecordsHavingContext(\n  pSentences: IMatch.IProcessedSentences, category: string, records: Array<IMatch.IRecord>,\n  categorySet: { [key: string]: boolean })\n  : IMatch.IProcessedWhatIsAnswers {\n\n  //debuglog(JSON.stringify(records, undefined, 2));\n  var relevantRecords = records.filter(function (record: IMatch.IRecord) {\n    return (record[category] !== undefined) && (record[category] !== null);\n  });\n  var res = [];\n  debuglog(\"MatchRecordsHavingContext : relevant records nr:\" + relevantRecords.length);\n  debuglog(debuglog.enabled ? (\"sentences are : \" + JSON.stringify(pSentences, undefined, 2)) : \"-\");\n  debuglog(debuglog.enabled ? (\"category \" + category + \" and categoryset is: \" + JSON.stringify(categorySet, undefined, 2)) : \"-\");\n  if (process.env.ABOT_FAST && categorySet) {\n    // we are only interested in categories present in records for domains which contain the category\n    // var categoryset = Model.calculateRelevantRecordCategories(theModel,category);\n    //knowing the target\n    perflog(\"got categoryset with \" + Object.keys(categorySet).length);\n    var fl = 0;\n    var lf = 0;\n    var aSimplifiedSentences = pSentences.sentences.map(function (oSentence) {\n      var fWords = oSentence.filter(function (oWord) {\n        return !Word.Word.isFiller(oWord);\n      });\n      var rWords = oSentence.filter(function (oWord) {\n        return !!categorySet[oWord.category] || Word.Word.isCategory(oWord);\n      });\n      fl = fl + oSentence.length;\n      lf = lf + rWords.length;\n      return {\n        oSentence: oSentence,\n        cntRelevantWords: rWords.length, // not a filler  // to be compatible it would be fWords\n        rWords: rWords\n      };\n    });\n    Object.freeze(aSimplifiedSentences);\n    debuglog(\"post simplify (r=\" + relevantRecords.length + \" s=\" + pSentences.sentences.length + \" fl \" + fl + \"->\" + lf + \")\");\n    perflog(\"post simplify (r=\" + relevantRecords.length + \" s=\" + pSentences.sentences.length + \" fl \" + fl + \"->\" + lf + \")\");\n    relevantRecords.forEach(function (record) {\n      // count matches in record which are *not* the category\n      aSimplifiedSentences.forEach(function (aSentence) {\n        var hasCategory = {};\n        var mismatched = {};\n        var matched = {};\n        var cntRelevantWords = aSentence.cntRelevantWords;\n        aSentence.rWords.forEach(function (oWord) {\n          if (oWord.category && (record[oWord.category] !== undefined)) {\n            if (oWord.matchedString === record[oWord.category]) {\n              matched[oWord.category] = oWord;\n            }\n            else {\n              mismatched[oWord.category] = oWord;\n            }\n          }\n          else if (Word.Word.isCategory(oWord) && record[oWord.matchedString]) {\n            hasCategory[oWord.matchedString] = 1;\n          }\n        }\n        );\n        if ((Object.keys(matched).length + Object.keys(hasCategory).length) > Object.keys(mismatched).length) {\n          res.push({\n            sentence: aSentence.oSentence,\n            record: record,\n            category: category,\n            result: record[category],\n            _ranking: calcRankingHavingCategory(matched, hasCategory, mismatched, cntRelevantWords)\n          });\n        }\n      })\n    });\n    debuglog(\"here in weird\");\n  } else {\n    relevantRecords.forEach(function (record) {\n      // count matches in record which are *not* the category\n      pSentences.sentences.forEach(function (aSentence) {\n        var hasCategory = {};\n        var mismatched = {};\n        var matched = {};\n        var cntRelevantWords = 0;\n        aSentence.forEach(function (oWord) {\n          if (!Word.Word.isFiller(oWord)) {\n            cntRelevantWords = cntRelevantWords + 1;\n            if (oWord.category && (record[oWord.category] !== undefined)) {\n              if (oWord.matchedString === record[oWord.category]) {\n                matched[oWord.category] = oWord;\n              }\n              else {\n                mismatched[oWord.category] = oWord;\n              }\n            }\n            else if (Word.Word.isCategory(oWord) && record[oWord.matchedString]) {\n              hasCategory[oWord.matchedString] = 1;\n            }\n          }\n        });\n        if ((Object.keys(matched).length + Object.keys(hasCategory).length) > Object.keys(mismatched).length) {\n          res.push({\n            sentence: aSentence,\n            record: record,\n            category: category,\n            result: record[category],\n            _ranking: calcRankingHavingCategory(matched, hasCategory, mismatched, cntRelevantWords)\n          });\n        }\n      })\n    });\n  }\n  res.sort(cmpByResultThenRanking);\n  debuglog(\" after sort\" + res.length);\n  var result = Object.assign({}, pSentences, { answers: res });\n  return filterRetainTopRankedResult(result);\n}\n*/\n\n/*\nexport function matchRecords(aSentences: IMatch.IProcessedSentences, category: string, records: Array<IMatch.IRecord>)\n  : IMatch.IProcessedWhatIsAnswers {\n  // if (debuglog.enabled) {\n  //   debuglog(JSON.stringify(records, undefined, 2));\n  // }\n  var relevantRecords = records.filter(function (record: IMatch.IRecord) {\n    return (record[category] !== undefined) && (record[category] !== null);\n  });\n  var res = [];\n  debuglog(\"relevant records nr:\" + relevantRecords.length);\n  relevantRecords.forEach(function (record) {\n    aSentences.sentences.forEach(function (aSentence) {\n      // count matches in record which are *not* the category\n      var mismatched = {}\n      var matched = {};\n      var cntRelevantWords = 0;\n      aSentence.forEach(function (oWord) {\n        if (!Word.Word.isFiller(oWord)) {\n          cntRelevantWords = cntRelevantWords + 1;\n          if (oWord.category && (record[oWord.category] !== undefined)) {\n            if (oWord.matchedString === record[oWord.category]) {\n              matched[oWord.category] = oWord;\n            } else {\n              mismatched[oWord.category] = oWord;\n            }\n          }\n        }\n      });\n      if (Object.keys(matched).length > Object.keys(mismatched).length) {\n        res.push({\n          sentence: aSentence,\n          record: record,\n          category: category,\n          result: record[category],\n          _ranking: calcRanking(matched, mismatched, cntRelevantWords)\n        });\n      }\n    })\n  });\n  res.sort(cmpByResultThenRanking);\n  var result = Object.assign({}, aSentences, { answers: res });\n  return filterRetainTopRankedResult(result);\n}\n*/\n/*\nfunction makeSimplifiedSentencesCategorySet(aSentences: IMatch.IProcessedSentences,\n  categorySet: { [key: string]: boolean }, track: { fl: number, lf: number }\n): {\n  domains: string[],\n  oSentence: IMatch.ISentence,\n  cntRelevantWords: number,\n  rWords: IMatch.IWord[]\n}[] {\n  return aSentences.sentences.map(function (oSentence) {\n    var aDomains = [] as string[];\n    var rWords = oSentence.filter(function (oWord) {\n      if (oWord.category === \"domain\") {\n        aDomains.push(oWord.matchedString);\n        return false;\n      }\n      if (oWord.category === \"meta\") {\n        // e.g. domain XXX\n        return false;\n      }\n      return !!categorySet[oWord.category];\n    });\n    track.fl += oSentence.length;\n    track.lf += rWords.length;\n    return {\n      domains: aDomains,\n      oSentence: oSentence,\n      cntRelevantWords: rWords.length,\n      rWords: rWords\n    };\n  });\n}\n*/\n\nfunction makeSimplifiedSentencesCategorySet2(aSentences: IMatch.IProcessedSentences,\n  categorySet: { [key: string]: boolean }, track: { fl: number, lf: number }\n): {\n  domains: string[],\n  oSentence: IMatch.ISentence,\n  cntRelevantWords: number,\n  rWords: IMatch.IWord[]\n}[] {\n  return aSentences.sentences.map(function (oSentence) {\n    var aDomains = [] as string[];\n    var rWords = oSentence.filter(function (oWord) {\n      if (oWord.category === \"domain\") {\n        aDomains.push(oWord.matchedString);\n        return false;\n      }\n      if (oWord.category === \"meta\") {\n        // e.g. domain XXX\n        return false;\n      }\n      if(oWord.category === \"category\") {\n        if(categorySet[oWord.matchedString]) {\n          return true;\n        }\n      }\n      return !!categorySet[oWord.category];\n    });\n    track.fl += oSentence.length;\n    track.lf += rWords.length;\n    return {\n      domains: aDomains,\n      oSentence: oSentence,\n      cntRelevantWords: rWords.length,\n      rWords: rWords\n    };\n  });\n}\n\n\nfunction makeSimplifiedSentences(aSentences : IMatch.IProcessedSentences,  track: { fl: number, lf: number }): {\n  domains: string[],\n  oSentence: IMatch.ISentence,\n  cntRelevantWords: number,\n  rWords: IMatch.IWord[]\n}[] {\n  return aSentences.sentences.map(function (oSentence) {\n    var domains = [] as string[];\n    var rWords = oSentence.filter(function (oWord) {\n      if (oWord.category === \"domain\") {\n        domains.push(oWord.matchedString);\n        return false;\n      }\n      if (oWord.category === \"meta\") {\n        // e.g. domain XXX\n        return false;\n      }\n      return !Word.Word.isFiller(oWord);\n    });\n    track.fl += oSentence.length;\n    track.lf += rWords.length;\n    return {\n      oSentence: oSentence,\n      domains: domains,\n      cntRelevantWords: rWords.length,\n      rWords: rWords\n    };\n  });\n}\n\n\nfunction extractResult(categories: string[], record: { [key: string]: string }): string[] {\n  return categories.map(function (category) { return record[category] || \"n/a\"; });\n}\n\nexport function matchRecordsQuickMultipleCategories(pSentences: IMatch.IProcessedSentences, categories: string[], records: Array<IMatch.IRecord>, domainCategoryFilter?: IMatch.IDomainCategoryFilter)\n  : IMatch.IProcessedWhatIsTupelAnswers {\n  // if (debuglog.enabled) {\n  //  debuglog(JSON.stringify(records, undefined, 2));\n  // }\n\n  if(domainCategoryFilter && ! domainCategoryFilter.domains ) {\n    throw new Error(\"old categorysSEt ??\")\n  }\n\n  Object.freeze(domainCategoryFilter);\n  var categoryF = categories[0];\n\n  debuglog(debuglog.enabled ? (\"matchRecordsQuickMultipleCategories (r=\" + (records && records.length)\n  + \" s=\" + (pSentences && pSentences.sentences && pSentences.sentences.length) + \")\\n categories:\" +(categories &&  categories.join(\"\\n\")) + \" categorySet: \"\n  + ( domainCategoryFilter && (typeof domainCategoryFilter.categorySet === \"object\") && Object.keys(domainCategoryFilter.categorySet).join(\"\\n\")))  : \"-\");\n  perflog(\"matchRecordsQuickMult ...(r=\" + records.length + \" s=\" + pSentences.sentences.length + \")\");\n\n  //console.log('categories ' +  JSON.stringify(categories));\n\n  //console.log('categroySet' +  JSON.stringify(categorySet));\n\n\n  var relevantRecords = records;\n\n  if(domainCategoryFilter && domainCategoryFilter.domains) {\n    relevantRecords = records.filter(function (record: IMatch.IRecord) {\n      return (domainCategoryFilter.domains.indexOf((record as any)._domain) >= 0);\n    });\n  }\n  else {\n    relevantRecords = relevantRecords.filter(function (record: IMatch.IRecord) {\n      return !categories.every(cat =>\n            (record[cat] === undefined) || (record[cat] === null)\n      );\n  //      }\n\n //     return (record[categoryF] !== undefined) && (record[categoryF] !== null);\n    });\n  }\n  var res = [] as Array<IMatch.IWhatIsTupelAnswer>;\n  debuglog(\"relevant records with first (r=\" + relevantRecords.length + \")\");\n  perflog(\"relevant records with first nr:\" + relevantRecords.length + \" sentences \" + pSentences.sentences.length);\n  if (/*process.env.ABOT_FAST &&*/ domainCategoryFilter) {\n    // we are only interested in categories present in records for domains which contain the category\n    // var categoryset = Model.calculateRelevantRecordCategories(theModel,category);\n    //knowing the target\n    perflog(\"got categoryset with \" + Object.keys(domainCategoryFilter.categorySet).length);\n    var obj = { fl: 0, lf: 0 };\n    var aSimplifiedSentences = [] as {\n      domains: string[],\n      oSentence: IMatch.ISentence,\n      cntRelevantWords: number,\n      rWords: IMatch.IWord[]\n    }[];\n  //  if (process.env.ABOT_BET1) {\n     aSimplifiedSentences = makeSimplifiedSentencesCategorySet2(pSentences, domainCategoryFilter.categorySet, obj) as any;\n  //  } else {\n  //    aSimplifiedSentences = makeSimplifiedSentencesCategorySet(pSentences, categorySet, obj) as any;\n  //  }\n    perflog(\"post simplify (r=\" + relevantRecords.length + \" s=\" + pSentences.sentences.length + \" fl \" + obj.fl + \"->\" + obj.lf + \")\");\n  } else {\n    debuglog(\"not abot_fast !\");\n    var track = { fl: 0 , lf : 0};\n    var aSimplifiedSentences = makeSimplifiedSentences(pSentences,track);\n/*\n    pSentences.sentences.map(function (oSentence) {\n      var rWords = oSentence.filter(function (oWord) {\n        return !Word.Word.isFiller(oWord);\n      });\n      fl = fl + oSentence.length;\n      lf = lf + rWords.length;\n      return {\n        oSentence: oSentence,\n        cntRelevantWords: rWords.length,\n        rWords: rWords\n      };\n    });\n    */\n    debuglog(\"post simplify (r=\" + relevantRecords.length + \" s=\" + pSentences.sentences.length + \" fl \" + track.fl + \"->\" + track.lf + \")\");\n    perflog(\"post simplify (r=\" + relevantRecords.length + \" s=\" + pSentences.sentences.length + \" fl \" + track.fl + \"->\" + track.lf + \")\");\n  }\n\n  debuglog(debuglog.enabled ? (\"here simplified sentences \" +\n  aSimplifiedSentences.map(o => \"\\nDomain=\" + o.domains.join(\"\\n\") + \"\\n\" +  Sentence.dumpNice(o.rWords)).join(\"\\n\")) : \"-\");\n\n  //console.log(\"here recrods\" + relevantRecords.map( (o,index) =>  \" index = \" + index + \" \" + JSON.stringify(o)).join(\"\\n\"));\n  relevantRecords.forEach(function (record) {\n    aSimplifiedSentences.forEach(function (aSentence) {\n      // count matches in record which are *not* the category\n      var imismatched = 0;\n      var imatched = 0;\n      var nouse = 0;\n      var foundcat = 1;\n      var missingcat = 0;\n\n      var matched = {};\n      var mismatched = {};\n      var hasCategory = {};\n\n      aSentence.rWords.forEach(function (oWord) {\n        var cntRelevantWords = 0;\n        if (record[oWord.category] !== undefined) {\n          if (oWord.matchedString === record[oWord.category]) {\n            ++imatched;\n          } else {\n            ++imismatched;\n          }\n        } else {\n          if (oWord.category !== \"category\") {\n            nouse += 1;\n          } else {\n            if (!record[oWord.matchedString]) {\n              missingcat += 1;\n            } else {\n              foundcat+= 1;\n            }\n          }\n        }\n        if (oWord.category && (record[oWord.category] !== undefined)) {\n            if (oWord.matchedString === record[oWord.category]) {\n              matched[oWord.category] = oWord;\n            } else {\n              mismatched[oWord.category] = oWord;\n            }\n        }\n        else if (Word.Word.isCategory(oWord) && record[oWord.matchedString]) {\n            hasCategory[oWord.matchedString] = 1;\n        } else if(!Word.Word.isCategory(oWord)) {\n           // TODO better unmachted\n            mismatched[oWord.category] = oWord;\n        }\n      });\n      var matchedDomain = 0;\n      var cntRelevantWords = aSentence.rWords.length;\n      if (aSentence.domains.length) {\n        if ((record as any)._domain !== aSentence.domains[0]) {\n          imismatched = 3000;\n        } else {\n          imatched += 1;\n          matchedDomain += 1;\n          //console.log(\"GOT A DOMAIN HIT\" + matched + \" \" + mismatched);\n        }\n      }\n      var matchedLen = Object.keys(matched).length + Object.keys(hasCategory).length;\n      var mismatchedLen = Object.keys(mismatched).length;\n      if ((imismatched < 3000)\n        && ((matchedLen > mismatchedLen)\n          || (matchedLen === mismatchedLen && matchedDomain > 0))\n      ) {\n        /*\n          debuglog(\"adding \" + extractResult(categories,record).join(\";\"));\n          debuglog(\"with ranking : \" + calcRankingHavingCategory2(matched, hasCategory, mismatched, cntRelevantWords, matchedDomain));\n          debuglog(\" created by \" + Object.keys(matched).map(key => \"key:\" + key\n          + \"\\n\" + JSON.stringify(matched[key])).join(\"\\n\")\n          + \"\\nhasCat \" + JSON.stringify(hasCategory)\n          + \"\\nmismat \" + JSON.stringify(mismatched)\n          + \"\\ncnTrel \" + JSON.stringify(cntRelevantWords)\n          + \"\\nmatcedDomain \" + JSON.stringify(matchedDomain)\n          + \"\\nhasCat \" + Object.keys(hasCategory)\n          + \"\\nmismat \" + Object.keys(mismatched)\n          + `\\nmatched ${Object.keys(matched)} \\nhascat ${Object.keys(hasCategory).join(\"; \")} \\nmism: ${Object.keys(mismatched)} \\n`\n          + \"\\nmatcedDomain \" + JSON.stringify(matchedDomain)\n\n          );\n          */\n\n        var rec = {\n          sentence: aSentence.oSentence,\n          record: record,\n          categories: categories,\n          result: extractResult(categories, record),\n          _ranking: calcRankingHavingCategory(matched, hasCategory, mismatched, cntRelevantWords, matchedDomain)\n        };\n        //console.log(\"here ranking\" + rec._ranking)\n        if ((rec._ranking === null) || !rec._ranking) {\n          rec._ranking = 0.9;\n        }\n        res.push(rec);\n      }\n    })\n  });\n  perflog(\"sort (a=\" + res.length + \")\");\n  res.sort(cmpByResultThenRankingTupel);\n  perflog(\"MRQMC filterRetain ...\");\n  var result1 = Object.assign({ tupelanswers: res }, pSentences);\n  /*debuglog(\"NEWMAP\" + res.map(o => \"\\nrank\" + o._ranking + \" =>\"\n              + o.result.join(\"\\n\")).join(\"\\n\")); */\n  var result2 = filterDistinctResultAndSortTupel(result1);\n  perflog(\"MRQMC matchRecordsQuick done: (r=\" + relevantRecords.length + \" s=\" + pSentences.sentences.length + \" a=\" + res.length + \")\");\n  return result2;\n}\n\n\nfunction classifyWordWithTargetCategory(word: string, targetcategory: string, rules: IMatch.SplitRules,\n  wholesentence: string): string {\n  //console.log(\"classify \" + word + \" \"  + targetcategory);\n  var cats = InputFilter.categorizeAWord(word, rules, wholesentence, {});\n  // TODO qualify\n  cats = cats.filter(function (cat) {\n    return cat.category === targetcategory;\n  })\n  //debuglog(JSON.stringify(cats));\n  if (cats.length) {\n    return cats[0].matchedString;\n  }\n}\n\n\nexport function analyzeCategory(categoryword: string, rules: IMatch.SplitRules, wholesentence: string): string {\n  return classifyWordWithTargetCategory(categoryword, 'category', rules, wholesentence);\n}\n\nexport function splitAtCommaAnd(str: string): string[] {\n  var r = str.split(/(\\band\\b)|[,]/);\n  r = r.filter(function (o, index) {\n    if (index % 2 > 0) {\n      return false;\n    }\n    return true;\n  });\n  var rtrimmed = r.map(function (o) {\n    return new String(o).trim();\n  });\n  return rtrimmed;\n}\n/**\n * A simple implementation, splitting at and and ,\n */\nexport function analyzeCategoryMultOnlyAndComma(categorylist: string, rules: IMatch.SplitRules, wholesentence: string): string[] {\n  var rtrimmed = splitAtCommaAnd(categorylist);\n  var rcat = rtrimmed.map(function (o) {\n    return analyzeCategory(o, rules, wholesentence);\n  });\n  if (rcat.indexOf(undefined) >= 0) {\n    throw new Error('\"' + rtrimmed[rcat.indexOf(undefined)] + '\" is not a category!');\n  }\n  return rcat;\n}\n\n\n\nexport function filterAcceptingOnly(res: IMatch.ICategorizedString[][], categories: string[]):\n  IMatch.ICategorizedString[][] {\n  return res.filter(function (aSentence, iIndex) {\n    return aSentence.every(function (oWord) {\n      return categories.indexOf(oWord.category) >= 0;\n    });\n  })\n}\n\n\n\n\nexport function processString(query: string, rules: IMatch.SplitRules\n): IMatch.IProcessedSentences {\n\n//  if (!process.env.ABOT_OLDMATCH) {\n    return ErBase.processString(query, rules, rules.wordCache);\n//  }\n/*\n  var matched = InputFilter.analyzeString(query, rules, sWords);\n  if (debuglog.enabled) {\n    debuglog(\"After matched \" + JSON.stringify(matched));\n  }\n  var aSentences = InputFilter.expandMatchArr(matched);\n  if (debuglog.enabled) {\n    debuglog(\"after expand\" + aSentences.map(function (oSentence) {\n      return Sentence.rankingProduct(oSentence) + \":\" + JSON.stringify(oSentence);\n    }).join(\"\\n\"));\n  }\n  var aSentencesReinforced = InputFilter.reinForce(aSentences);\n  if (debuglog.enabled) {\n    debuglog(\"after reinforce\" + aSentencesReinforced.map(function (oSentence) {\n      return Sentence.rankingProduct(oSentence) + \":\" + JSON.stringify(oSentence);\n    }).join(\"\\n\"));\n  }\n  return {\n    errors: [],\n    sentences: aSentencesReinforced\n  } as IMatch.IProcessedSentences;\n*/\n}\n\n\nexport function analyzeContextString(contextQueryString: string, rules: IMatch.SplitRules):\n  IMatch.IProcessedSentences {\n\n  var aSentencesReinforced = processString(contextQueryString, rules)\n  // we limit analysis to n sentences\n  aSentencesReinforced.sentences = aSentencesReinforced.sentences.slice(0, Algol.Cutoff_Sentences);\n  if (debuglog.enabled) {\n    debuglog(\"after reinforce and cutoff\" + aSentencesReinforced.sentences.length + \"\\n\" + aSentencesReinforced.sentences.map(function (oSentence) {\n      return Sentence.rankingProduct(oSentence) + \":\" + JSON.stringify(oSentence);\n    }).join(\"\\n\"));\n  }\n  return aSentencesReinforced;\n}\n\nexport function cmpByNrCategoriesAndSameDomain(a: IMatch.ISentence, b: IMatch.ISentence): number {\n  //console.log(\"compare a\" + a + \" cntb \" + b);\n  var cnta = Sentence.getDistinctCategoriesInSentence(a).length;\n  var cntb = Sentence.getDistinctCategoriesInSentence(b).length;\n  /*\n    var cnta = a.reduce(function(prev, oWord) {\n      return prev + ((oWord.category === \"category\")? 1 : 0);\n    },0);\n    var cntb = b.reduce(function(prev, oWord) {\n      return prev + ((oWord.category === \"category\")? 1 : 0);\n    },0);\n   // console.log(\"cnt a\" + cnta + \" cntb \" + cntb);\n   */\n  return cntb - cnta;\n}\n\nexport function analyzeCategoryMult(categorylist: string, rules: IMatch.SplitRules, wholesentence: string, gWords:\n  { [key: string]: IMatch.ICategorizedString[] }): string[] {\n\n\n\n\n\n  var res = analyzeContextString(categorylist, rules);\n  //  debuglog(\"resulting category sentences\", JSON.stringify(res));\n  var res2 = filterAcceptingOnly(res.sentences, [\"category\", \"filler\"]);\n  //  console.log(\"here res2\" + JSON.stringify(res2) );\n  //  console.log(\"here undefined ! + \" + res2.filter(o => !o).length);\n  res2.sort(Sentence.cmpRankingProduct);\n  debuglog(\"resulting category sentences: \\n\", debuglog.enabled ? (Sentence.dumpNiceArr(res2.slice(0, 3), Sentence.rankingProduct)) : '-');\n  // TODO:   res2 = filterAcceptingOnlySameDomain(res2);\n  //debuglog(\"resulting category sentences\", JSON.stringify(res2, undefined, 2));\n  // expect only categories\n  // we could rank now by common domains , but for now we only take the first one\n  if (!res2.length) {\n    return undefined;\n  }\n  //res.sort(cmpByNrCategoriesAndSameDomain);\n  var rescat = Sentence.getDistinctCategoriesInSentence(res2[0]);\n  return rescat;\n  // \"\" return res[0].filter()\n  // return classifyWordWithTargetCategory(categorylist, 'category', rules, wholesentence);\n}\n\nexport function analyzeOperator(opword: string, rules: IMatch.SplitRules, wholesentence: string): string {\n  return classifyWordWithTargetCategory(opword, 'operator', rules, wholesentence);\n}\n\n\nimport * as ListAll from './listall';\n// const result = WhatIs.resolveCategory(cat, a1.entity,\n//   theModel.mRules, theModel.tools, theModel.records);\n\n\nexport function resolveCategory(category: string, contextQueryString: string,\n  rules: IMatch.SplitRules, records: Array<IMatch.IRecord>): IMatch.IProcessedWhatIsAnswers {\n  if (contextQueryString.length === 0) {\n    return { errors: [ErError.makeError_EMPTY_INPUT()], tokens: [], answers: [] };\n  } else {\n    /*\n        var matched = InputFilter.analyzeString(contextQueryString, rules);\n        debuglog(debuglog.enabled ? (\"after matched \" + JSON.stringify(matched)): '-');\n        var aSentences = InputFilter.expandMatchArr(matched);\n        if(debuglog.enabled) {\n          debuglog(\"after expand\" + aSentences.map(function (oSentence) {\n            return Sentence.rankingProduct(oSentence) + \":\" + JSON.stringify(oSentence);\n          }).join(\"\\n\"));\n      } */\n\n\n          // var categorySet = Model.getAllRecordCategoriesForTargetCategory(theModel, cat, true);\n\n    var res = ListAll.listAllWithContext(category, contextQueryString, rules, records);\n    //* sort by sentence\n    res.answers.forEach(o => { o._ranking = o._ranking *  Sentence.rankingProduct( o.sentence ); });\n    res.answers.sort(cmpByRanking);\n    return res;\n/*\n    // ??? var res = ListAll.listAllHavingContext(category, contextQueryString, rules, records);\n\n    var aSentencesReinforced = processString(contextQueryString, rules);\n    //aSentences.map(function(oSentence) { return InputFilter.reinForce(oSentence); });\n    debuglog(debuglog.enabled ? (\"after reinforce\" + aSentencesReinforced.sentences.map(function (oSentence) {\n      return Sentence.rankingProduct(oSentence) + \":\" + JSON.stringify(oSentence);\n    }).join(\"\\n\")) : '-');\n    var matchedAnswers = matchRecords(aSentencesReinforced, category, records); //aTool: Array<IMatch.ITool>): any / * objectstream* / {\n    debuglog(debuglog.enabled ? (\" matchedAnswers\" + JSON.stringify(matchedAnswers, undefined, 2)) : '-');\n    return matchedAnswers;\n*/\n }\n}\n\n/*\nexport function resolveCategoryOld(category: string, contextQueryString: string,\n  rules: IMatch.SplitRules, records: Array<IMatch.IRecord>): IMatch.IProcessedWhatIsAnswers {\n  if (contextQueryString.length === 0) {\n    return { errors: [ErError.makeError_EMPTY_INPUT()], tokens: [], answers: [] };\n  } else {\n    var aSentencesReinforced = processString(contextQueryString, rules);\n    //aSentences.map(function(oSentence) { return InputFilter.reinForce(oSentence); });\n    debuglog(debuglog.enabled ? (\"after reinforce\" + aSentencesReinforced.sentences.map(function (oSentence) {\n      return Sentence.rankingProduct(oSentence) + \":\" + JSON.stringify(oSentence);\n    }).join(\"\\n\")) : '-');\n    var matchedAnswers = matchRecords(aSentencesReinforced, category, records); //aTool: Array<IMatch.ITool>): any / * objectstream* / {\n    debuglog(debuglog.enabled ? (\" matchedAnswers\" + JSON.stringify(matchedAnswers, undefined, 2)) : '-');\n    return matchedAnswers;\n  }\n}\n*/\n\n\nexport function resolveCategories(categories: string[], contextQueryString: string,\n  theModel: IMatch.IModels, domainCategoryFilter : IMatch.IDomainCategoryFilter): IMatch.IProcessedWhatIsTupelAnswers {\n  var records = theModel.records;\n  var rules = theModel.rules;\n  if (contextQueryString.length === 0) {\n    return {\n      errors: [ErError.makeError_EMPTY_INPUT()],\n      tupelanswers: [],\n      tokens: []\n    }\n  } else {\n    // var categorySet = Model.getAllRecordCategoriesForTargetCategory(theModel, cat, true);\n    var res = ListAll.listAllTupelWithContext(categories, contextQueryString, rules, records, domainCategoryFilter);\n    //* sort by sentence\n    res.tupelanswers.forEach(o => { o._ranking = o._ranking *  Sentence.rankingProduct( o.sentence ); });\n    res.tupelanswers.sort(cmpByRankingTupel);\n    return res;\n  }\n}\n\nexport function isIndiscriminateResult(results: Array<IMatch.IWhatIsAnswer>): string {\n  var cnt = results.reduce(function (prev, result) {\n    if (safeEqual(result._ranking,results[0]._ranking)) {\n      return prev + 1;\n    }\n  }, 0);\n  if (cnt > 1) {\n    // search for a discriminating category value\n    var discriminating = Object.keys(results[0].record).reduce(function (prev, category) {\n      if ((category.charAt(0) !== '_' && category !== results[0].category)\n        && (results[0].record[category] !== results[1].record[category])) {\n        prev.push(category);\n      }\n      return prev;\n    }, []);\n    if (discriminating.length) {\n      return \"Many comparable results, perhaps you want to specify a discriminating \" + discriminating.join(',');\n    }\n    return 'Your question does not have a specific answer';\n  }\n  return undefined;\n}\n\nexport function isIndiscriminateResultTupel(results: Array<IMatch.IWhatIsTupelAnswer>): string {\n  var cnt = results.reduce(function (prev, result) {\n    if (safeEqual(result._ranking,results[0]._ranking)) {\n      return prev + 1;\n    }\n  }, 0);\n  if (cnt > 1) {\n    // search for a discriminating category value\n    var discriminating = Object.keys(results[0].record).reduce(function (prev, category) {\n      if ((category.charAt(0) !== '_' && results[0].categories.indexOf(category) < 0)\n        && (results[0].record[category] !== results[1].record[category])) {\n        prev.push(category);\n      }\n      return prev;\n    }, []);\n    if (discriminating.length) {\n      return \"Many comparable results, perhaps you want to specify a discriminating \" + discriminating.join(',') + ' or use \"list all ...\"';\n    }\n    return 'Your question does not have a specific answer';\n  }\n  return undefined;\n}\n"],"sourceRoot":"ABC"}